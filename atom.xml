<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Onions说前端 - 从未如此简单有趣</title>
  
  <subtitle>不要跟我谈理想，我的理想是不上班</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://algate.github.io/"/>
  <updated>2019-08-26T03:32:22.087Z</updated>
  <id>http://algate.github.io/</id>
  
  <author>
    <name>onions</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript好用的Web-Api</title>
    <link href="http://algate.github.io/archives/JS190826.html"/>
    <id>http://algate.github.io/archives/JS190826.html</id>
    <published>2019-08-26T02:57:30.000Z</published>
    <updated>2019-08-26T03:32:22.087Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 13:38:15 GMT+0800 (GMT+08:00) --><h3 id="1-closest（元素向上查询）"><a href="#1-closest（元素向上查询）" class="headerlink" title="1.closest（元素向上查询）"></a>1.closest（元素向上查询）</h3><ul><li>closest<br>跟querySelector相反，该元素可以向上查询，也就是可以查询到父元素：<br>document.querySelector(“li”).closest(“#nav”);</li></ul><h3 id="2-dataset（获取元素以”data-“为前缀的属性集合）"><a href="#2-dataset（获取元素以”data-“为前缀的属性集合）" class="headerlink" title="2.dataset（获取元素以”data-“为前缀的属性集合）"></a>2.dataset（获取元素以”data-“为前缀的属性集合）</h3><ul><li>dataset<br>就跟原生微信小程序一样，能获取标签上以”data-“为前缀的属性集合：</li></ul><p></p><p data-name="蜘蛛侠" data-age="16"></p><br>document.querySelector(“p”).dataset; // {name: “蜘蛛侠”, age: “16”}<br>注意：虽然可以用getAttribute方法获取任何属性值，但是性质却不一样，这是开发规范问题，凡是自定义属性都要加上data-前缀哦<p></p><h3 id="3-URLSearchParams（查询参数）"><a href="#3-URLSearchParams（查询参数）" class="headerlink" title="3.URLSearchParams（查询参数）"></a>3.URLSearchParams（查询参数）</h3><ul><li>URLSearchParams<br>假设浏览器的url参数是 “?name=蜘蛛侠&amp;age=16”：</li></ul><h3 id="4-hidden（隐藏元素）"><a href="#4-hidden（隐藏元素）" class="headerlink" title="4.hidden（隐藏元素）"></a>4.hidden（隐藏元素）</h3><p>这是一个html属性，规定元素是否隐藏，表现跟css的display: none一致：<br><code>&lt;div hidden&gt;我被隐藏了&lt;/div&gt;</code><br><code>document.querySelector(&quot;div&quot;).hidden = true / false;</code></p><h3 id="5-classList（类名控制器）"><a href="#5-classList（类名控制器）" class="headerlink" title="5.classList（类名控制器）"></a>5.classList（类名控制器）</h3><ul><li>classList<br>这是一个对象，该对象里封装了许多操作元素类名的方法：<br><code>&lt;p class=&quot;title&quot;&gt;&lt;/p&gt;</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> elem = <span class="built_in">document</span>.querySelector(<span class="string">"p"</span>);</span><br><span class="line"><span class="comment">// 增加类名</span></span><br><span class="line">elem.classList.add(<span class="string">"title-new"</span>); <span class="comment">// "title title-new"</span></span><br><span class="line"><span class="comment">// 删除类名</span></span><br><span class="line">elem.classList.remove(<span class="string">"title"</span>); <span class="comment">// "title-new"</span></span><br><span class="line"><span class="comment">// 切换类名（有则删、无则增，常用于一些切换操作，如显示/隐藏）</span></span><br><span class="line">elem.classList.toggle(<span class="string">"title"</span>); <span class="comment">// "title-new title"</span></span><br><span class="line"><span class="comment">// 替换类名</span></span><br><span class="line">elem.classList.replace(<span class="string">"title"</span>, <span class="string">"title-old"</span>); <span class="comment">// "title-new title-old"</span></span><br><span class="line"><span class="comment">// 是否包含指定类名</span></span><br><span class="line">elem.classList.contains(<span class="string">"title"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-contains（判断是否包含指定元素）"><a href="#6-contains（判断是否包含指定元素）" class="headerlink" title="6.contains（判断是否包含指定元素）"></a>6.contains（判断是否包含指定元素）</h3><ul><li>contains<br>可以判断指定元素是否包含了指定的子元素：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">document.querySelector("div").contains(document.querySelector("p")); // true</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-online-state（网络状态）"><a href="#7-online-state（网络状态）" class="headerlink" title="7.online state（网络状态）"></a>7.online state（网络状态）</h3><ul><li>online state<br>监听当前的网络状态变动，然后执行对应的方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"online"</span>, xxx);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"offline"</span>, () =&gt; &#123;</span><br><span class="line">  alert(<span class="string">"你断网啦！"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>使用场景：提示用户已断网，直接一个弹框把用户吓懵</p><h3 id="8-battery-state（电池状态）"><a href="#8-battery-state（电池状态）" class="headerlink" title="8.battery state（电池状态）"></a>8.battery state（电池状态）</h3><ul><li>battery state<br>获取设备的电池状态：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">navigator.getBattery().then(<span class="function"><span class="params">battery</span> =&gt;</span> <span class="built_in">console</span>.log(battery));</span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line">&#123;</span><br><span class="line">  charging, <span class="comment">// 是否在充电</span></span><br><span class="line">  chargingTime, <span class="comment">// 充满电所需时间</span></span><br><span class="line">  dischargingTime, <span class="comment">// 当前电量可使用时间</span></span><br><span class="line">  level, 剩余电量</span><br><span class="line"></span><br><span class="line">  onchargingchange, <span class="comment">// 监听充电状态变化</span></span><br><span class="line">  onchargingtimechange, <span class="comment">// 监听充满电所需时间变化</span></span><br><span class="line">  ondischargingtimechange, <span class="comment">// 监听当前电量可使用时间变化</span></span><br><span class="line">  onlevelchange <span class="comment">// 监听电量变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用场景：提示用户电量已充满，或者为了让用户有安全感，电量低于99%的时候来个弹框提示”该充电啦”</p><h3 id="9-vibration（设备震动）"><a href="#9-vibration（设备震动）" class="headerlink" title="9.vibration（设备震动）"></a>9.vibration（设备震动）</h3><p>嘻嘻，使设备进行震动：<br>// 震动一次<br>navigator.vibrate(100);<br>// 连续震动，震动200ms、暂停100ms、震动300ms<br>navigator.vibrate([200, 100, 300]);<br>效果如下：不好意思你得用你自己的手握住手机才能感受得到;<br>使用场景：通过振动来提供感官反馈，比如太久没有触摸屏幕的时候连续震动提醒用户</p><h3 id="10-page-visibility（页面可见性）"><a href="#10-page-visibility（页面可见性）" class="headerlink" title="10.page visibility（页面可见性）"></a>10.page visibility（页面可见性）</h3><p>顾名思义，这个API是用来监听页面可见性变化的，在PC端标签栏切换、最小化会触发、在移动端程序切到后台会触发，简单说就是页面消失了🤦‍♂️<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`页面可见性：<span class="subst">$&#123;<span class="built_in">document</span>.visibilityState&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>PC端效果如下：<br><img src="/images/js_webapi_visibility.gif" alt="image"><br>移动端效果如下：<br><img src="/images/js_webapi_visibility_app.gif" alt="image"><br>使用场景：当程序切到后台的时候，如果当前有视频播放或者一些动画执行，可以先暂停</p><h3 id="11-deviceOrientation（陀螺仪）"><a href="#11-deviceOrientation（陀螺仪）" class="headerlink" title="11.deviceOrientation（陀螺仪）"></a>11.deviceOrientation（陀螺仪）</h3><ul><li>deviceOrientation<br>陀螺仪，也就是设备的方向，又名重力感应，该API在IOS设备上失效的解决办法，将域名协议改成https；<br><img src="/images/js_webapi_deviceOrientation.jpg" alt="image"><br>从左到右分别为alpha、beta、gamma:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"deviceorientation"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;</span><br><span class="line">    alpha,</span><br><span class="line">    beta,</span><br><span class="line">    gamma</span><br><span class="line">  &#125; = event;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`alpha：<span class="subst">$&#123;alpha&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`beta：<span class="subst">$&#123;beta&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`gamma：<span class="subst">$&#123;gamma&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>使用场景：页面上的某些元素需要根据手机摆动进行移动，达到视差的效果，比如王者荣耀进入游戏的那个界面，手机转动背景图会跟着动</p><h3 id="12-toDataUrl（画布内容转base64）"><a href="#12-toDataUrl（画布内容转base64）" class="headerlink" title="12.toDataUrl（画布内容转base64）"></a>12.toDataUrl（画布内容转base64）</h3><ul><li>toDataURL<br>这个canvas的API，作用是将画布的内容转换成一个base64的图片地址：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="keyword">let</span> url = canvas.toDataURL(<span class="string">"image/png"</span>); <span class="comment">// 将画布内容转换成base64地址</span></span><br></pre></td></tr></table></figure></li></ul><p>使用a标签进行图片下载时，图片链接跨域（图片是我的掘金头像），无法进行下载而是进行图片预览：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"xxx"</span> <span class="attr">download</span>=<span class="string">"avatar"</span>&gt;</span>下载图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>封装以下代码便可解决✅<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadImage = <span class="function">(<span class="params">url, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 实例化画布</span></span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">  <span class="keyword">let</span> context = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">  <span class="comment">// 实例化一个图片对象</span></span><br><span class="line">  <span class="keyword">let</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.crossOrigin = <span class="string">"Anonymous"</span>;</span><br><span class="line">  image.src = url;</span><br><span class="line">  <span class="comment">// 当图片加载完毕</span></span><br><span class="line">  image.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将图片画在画布上</span></span><br><span class="line">    canvas.height = image.height;</span><br><span class="line">    canvas.width = image.width;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将画布的内容转换成base64地址</span></span><br><span class="line">    <span class="keyword">let</span> dataURL = canvas.toDataURL(<span class="string">"image/png"</span>);</span><br><span class="line">    <span class="comment">// 创建a标签模拟点击进行下载</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">    a.hidden = <span class="literal">true</span>;</span><br><span class="line">    a.href = dataURL;</span><br><span class="line">    a.download = name;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">    a.click();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>或者将当前的DOM转换成图片进行下载，常用于生成海报，推荐插件html2canvas，大家可以自己去搜;</p><h3 id="13-customEvent（自定义事件）"><a href="#13-customEvent（自定义事件）" class="headerlink" title="13.customEvent（自定义事件）"></a>13.customEvent（自定义事件）</h3><ul><li>customEvent<br>自定义事件，就跟vue里面的on跟emit一样；</li></ul><p>监听自定义事件：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"follow"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.detail); <span class="comment">// 输出 &#123;name: "前端宇宙情报局"&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line">派发自定义事件：</span><br><span class="line"><span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">"follow"</span>, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    name: <span class="string">"前端宇宙情报局"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p></p><h3 id="14-notification（桌面通知）"><a href="#14-notification（桌面通知）" class="headerlink" title="14.notification（桌面通知）"></a>14.notification（桌面通知）</h3><ul><li>notification<br>PC端的桌面通知，如网页端的微信，当收到消息时，右下角会出现一个通知（尽管你把浏览器最小化），因为这个通知时独立于浏览器的，是系统的一个原生控件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notice = <span class="keyword">new</span> Notification(<span class="string">"前端宇宙情报局"</span>, &#123;</span><br><span class="line">  body: <span class="string">"这20个不常用的Web API真的有用吗?，别问，问就是有用🈶"</span>,</span><br><span class="line">  icon: <span class="string">"我的掘金头像"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    url: <span class="string">"https://www.baidu.com"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 点击回调</span></span><br><span class="line">notice.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.open(notice.data.url); <span class="comment">// 当用户点击通知时，在浏览器打开百度网站</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>效果如下：<br><img src="/images/js_webapi_notification.gif" alt="image"></p><p>注意：想要成功的调起通知，首先要用户的授权✅</p><p>Notification.requestPermission(prem =&gt; {<br>prem == “granted” // 同意<br>prem == “denied” // 拒绝<br>})<br>所以，再调用之前先向用户发起请求：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> permission = Notification.permission;</span><br><span class="line"><span class="keyword">if</span> (permission == <span class="string">"granted"</span>) &#123;</span><br><span class="line">  <span class="comment">// 已同意，开始发送通知</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (permission == <span class="string">"denied"</span>) &#123;</span><br><span class="line">  <span class="comment">// 不同意，发不了咯</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 其他状态，可以重新发送授权提示</span></span><br><span class="line">  Notification.requestPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="15-fullScreen（全屏）"><a href="#15-fullScreen（全屏）" class="headerlink" title="15.fullScreen（全屏）"></a>15.fullScreen（全屏）</h3><ul><li>fullScreen<br>全屏不咯? 之前的一个项目刚好用上，不仅仅可以作用在documentElement上，还可以作用在指定元素：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @method launchFullScreen 开启全屏</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; elem = document.documentElement 作用的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> launchFullScreen = <span class="function">(<span class="params">elem = <span class="built_in">document</span>.documentElement</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(elem.requestFullScreen) &#123;</span><br><span class="line">    elem.requestFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(elem.mozRequestFullScreen) &#123;</span><br><span class="line">    elem.mozRequestFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(elem.webkitRequestFullScreen) &#123;</span><br><span class="line">    elem.webkitRequestFullScreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>作用在documentElement上没啥可以介绍的咯，就相当于F11开启全屏：<br>那么作用在指定元素会是什么效果呢?<br><img src="/images/js_webapi_fullScreen.gif" alt="image"><br>就像效果图一样，会直接开启全屏，并且只显示指定的元素，元素的宽高填充了整个屏幕✅<br>关闭全屏的时候需要注意的是，统一用document对象：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @method exitFullScreen 关闭全屏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> exitFullScreen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.exitFullscreen) &#123;</span><br><span class="line">    <span class="built_in">document</span>.exitFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.mozCancelFullScreen) &#123;</span><br><span class="line">    <span class="built_in">document</span>.mozCancelFullScreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.webkitCancelFullScreen) &#123;</span><br><span class="line">    <span class="built_in">document</span>.webkitCancelFullScreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用场景：需要让用户专注去做某件事，比如代码编辑区的全屏</p><h3 id="16-orientation（屏幕方向）"><a href="#16-orientation（屏幕方向）" class="headerlink" title="16.orientation（屏幕方向）"></a>16.orientation（屏幕方向）</h3><ul><li>orientation<br>可以监听用户手机设备的旋转方向变化：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"orientationchange"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerHTML += <span class="string">`&lt;p&gt;屏幕旋转后的角度值：<span class="subst">$&#123;<span class="built_in">window</span>.orientation&#125;</span>&lt;/p&gt;`</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li></ul><p>效果如下：<br><img src="/images/js_webapi_orientation.gif" alt="image"><br>也可以使用css的媒体查询：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 竖屏时样式 */</span></span><br><span class="line">@media all and (orientation: portrait) &#123;</span><br><span class="line">  body::after &#123;</span><br><span class="line">    content: <span class="string">"竖屏"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 横屏时样式 */</span></span><br><span class="line">@media all and (orientation: landscape) &#123;</span><br><span class="line">  body::after &#123;</span><br><span class="line">    content: <span class="string">"横屏"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用场景：页面需要用户开启横屏来获得更好的体验</p><h3 id="17-getBoundingClientRect（元素空间结构详细信息）"><a href="#17-getBoundingClientRect（元素空间结构详细信息）" class="headerlink" title="17.getBoundingClientRect（元素空间结构详细信息）"></a>17.getBoundingClientRect（元素空间结构详细信息）</h3><ul><li>getBoundingClientRect<br>可以获取指定元素在当前页面的空间信息：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">elem.getBoundingClientRect();</span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line">&#123;</span><br><span class="line">  x: <span class="number">604.875</span>,</span><br><span class="line">  y: <span class="number">1312</span>,</span><br><span class="line">  width: <span class="number">701.625</span>,</span><br><span class="line">  height: <span class="number">31</span>,</span><br><span class="line">  top: <span class="number">1312</span>,</span><br><span class="line">  right: <span class="number">1306.5</span>,</span><br><span class="line">  bottom: <span class="number">1343</span>,</span><br><span class="line">  left: <span class="number">604.875</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：top是距离文档顶部的距离，y则是距离可视窗口（浏览器屏幕）的顶部距离，如果浏览器滚动，top值不变，y值会变</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 13:38:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;1-closest（元素向上查询）&quot;&gt;&lt;a href=&quot;#1-closest（元素向上查询）&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="前端" scheme="http://algate.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://algate.github.io/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="http://algate.github.io/tags/WebApi/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript工具相关使用</title>
    <link href="http://algate.github.io/archives/JS190426.html"/>
    <id>http://algate.github.io/archives/JS190426.html</id>
    <published>2019-04-26T02:38:30.000Z</published>
    <updated>2019-08-26T03:33:07.431Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 13:38:15 GMT+0800 (GMT+08:00) --><h3 id="1-serve"><a href="#1-serve" class="headerlink" title="1.serve"></a>1.serve</h3><p>不用express,不用部署http环境,可以直接运行编译后代码</p><p>用法：serve -s ./docs -p 8888</p><p>安装：node环境<br>全局安装 serve 依赖 （ cnpm install -g serve ）</p><h3 id="2-font-spider"><a href="#2-font-spider" class="headerlink" title="2.font-spider"></a>2.font-spider</h3><p>打包文件之后，可以压缩页面中引用的字体文件（字体图标除外）</p><p>用法：font-spider ./html文件路径</p><p>安装：cnpm install font-spider -g</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 13:38:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;1-serve&quot;&gt;&lt;a href=&quot;#1-serve&quot; class=&quot;headerlink&quot; title=&quot;1.serve&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://algate.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://algate.github.io/tags/JavaScript/"/>
    
      <category term="打包工具" scheme="http://algate.github.io/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>睡前收入睡后收入第一节</title>
    <link href="http://algate.github.io/archives/54500.html"/>
    <id>http://algate.github.io/archives/54500.html</id>
    <published>2019-04-16T12:19:00.000Z</published>
    <updated>2019-08-26T02:33:40.614Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 10:34:19 GMT+0800 (GMT+08:00) --><blockquote><blockquote><p>睡前收入，睡后收入。你能明白，你就实现了自由！</p></blockquote></blockquote><p><img src="/images/note01-01.jpg" alt="image"></p><p>一个人，只要不是含着金钥匙出生的，财富最初总是靠出售体力或智力劳动换来的，并在满足我们消费需求之后，通过配置在不同的资产上获取。套用一句流行语，或者是“睡前收入”，或者是“睡后收入”。</p><p>所谓睡前收入，就是你干活就有、睡着了就没有的那种，使用自己的体力或者智力还钱。所谓睡后收入，就是被动性收入，哪怕你睡着了，它也在自动增值。两种收入形态中，很明显，睡后收入占比越高，你就有越多可供自由支配的时间，所做选择受到的制约也就越少。收入来源全部由睡后收入构成，就进入了所谓财务自由状态。</p><p>受限于认知水平，我们最先接触到的睡后收入，可能都是银行存款,还是年回报率“高”达0.35%的活期存款，其后由于你多学习了一点点，你可能开始会搞阿里余额宝、腾讯理财通、甲银行B理财…… ，收益率开始从0.35%提升到3%~5%之间。<br>这一步很容易实现，是因为这个回报率依然远在社会平均财富增长值之下，属于将自己辛辛苦苦卖体力或者脑力换来的财富，无偿地送给别人一部分。将财富从自己口袋里掏出来.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 10:34:19 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;睡前收入，睡后收入。你能明白，你就实现了自由！&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockq
      
    
    </summary>
    
      <category term="日记" scheme="http://algate.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="理财" scheme="http://algate.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>史上最全的Webstorm快捷键及技巧</title>
    <link href="http://algate.github.io/archives/47814.html"/>
    <id>http://algate.github.io/archives/47814.html</id>
    <published>2017-09-21T02:44:48.000Z</published>
    <updated>2019-08-26T02:27:05.193Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 11:32:59 GMT+0800 (GMT+08:00) --><blockquote><p>Webstorm是一款前端开发神器，此文介绍webstorm的快捷键和技巧分享。</p></blockquote><p>所谓工欲善其事，必先利其器嘛，想着如果要提高开发效率，那掌握一些常用的快捷键应该是少不了的，所以把webstorm快捷键及技巧分享给大家。持续更新中</p><p>webstorm官方下载地址：<a href="http://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">http://www.jetbrains.com/webstorm/</a></p><h2 id="快捷键大全"><a href="#快捷键大全" class="headerlink" title="快捷键大全"></a>快捷键大全</h2><h3 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h3><hr><p>【Ctrl + Space 】基本代码完成 （任何类、 方法或变量名称）<br>【Alt + Enter】 展示意图动作和快速修复<br>【Ctrl + P】显示调用方法内参数信息<br>【Ctrl + Q】 快速记录查找<br>【Ctrl + mouse】放在代码上面-显示简短的代码信息<br>【Ctrl + F1】在插入符号显示错误或警告的说明<br>【Alt + Insert】生成代码<br>【Ctrl + Alt + T】快速生成（if..else, try..catch, for, etc.）等<br>【Ctrl + J】插入Live模板<br>【Ctrl + / 】行注释与取消行注释<br>【Ctrl + Shift + / 】块注释与取消块注释<br>【Ctrl + W 】增加选择中代码块<br>【Ctrl + Shift + W 】减少当前所选内容代码块<br>【Alt + Q 】上下文信息<br>【Ctrl + Alt + L 】格式化代码<br>【Ctrl + Alt + I 】自动缩进的行数<br>【Tab / Shift + Tab 】缩进/取消缩进选定的行<br>【Ctrl + X , Shift + Delete】 剪切到剪贴板的当前行或者所选代码块<br>【Ctrl + C】Ctrl + 插入复制当前行或者所选代码块到剪贴板<br>【Ctrl + V】Shift + 从剪贴板插入粘贴<br>【Ctrl + Shift + V 】最近缓冲区粘贴<br>【Ctrl + D】复制当前行或者所选代码块<br>【Ctrl + Y】删除行<br>【Ctrl + Shift + J 】加入行<br>【Ctrl + enter 】拆分行<br>【shift + Enter 】 重新开始一行（无论光标在哪个位置）<br>【Ctrl + Shift + U 】切换选中词或所选代码块的大小写<br>【Ctrl + Shift +]】选中直到代码块的开始<br>【Ctrl + Shift +[】选择直到代码块的结束<br>【Ctrl + Delete】 删除光标右侧的词<br>【Ctrl + backspace】 删除光标左侧的词<br>【Ctrl + NumPad+】展开代码块<br>【Ctrl + NumPad-】折叠代码块<br>【Ctrl + Shift + NumPad+】展开所有代码块<br>【Ctrl + Shift + NumPad-】折叠所有代码块<br>【Ctrl + F4 】关闭当前标签页</p><h3 id="同时编辑多行"><a href="#同时编辑多行" class="headerlink" title="同时编辑多行"></a>同时编辑多行</h3><hr><p>【Alt + Click】 同时选中多行，同时编辑<br>【Shift + Ctrl + Alt + J】选择所有当前选中的词<br>【Alt + J】选择下一个相同的词<br>【Alt + Shift + J】取消所有选中的词<br>【Esc】取消选择所有选中的词或插入符号</p><h3 id="运行类"><a href="#运行类" class="headerlink" title="运行类"></a>运行类</h3><hr><p>【Alt + Shift + F10/F9】 选择配置和运行/调试<br>【Shift + F10/F9】 运行/调试<br>【Ctrl + Shift + F10/F9】 运行/调试上下文配置从编辑器<br>【Alt + Shift + R】 重新运行测试</p><h3 id="调试类"><a href="#调试类" class="headerlink" title="调试类"></a>调试类</h3><hr><p>【F8】不进入函数<br>【F7】 单步执行<br>【Shift + F7】 只能单步执行<br>【Shift + F8】跳出<br>【Alt + F9】 运行到光标处<br>【Alt + F8】 计算表达式的值<br>【F9】 重新开始<br>【Ctrl + f8】 切换断点<br>【Ctrl + Shift + F8】 查看断点</p><h3 id="导航类"><a href="#导航类" class="headerlink" title="导航类"></a>导航类</h3><hr><p>【Ctrl + N】跳转到指定类<br>【Ctrl + Shift + N】 通过文件名快速查找工程内的文件<br>【Ctrl + Alt + Shift + N】 通过一个字符查找函数位置<br>【Alt + Right】进入下一个编辑器选项<br>【Alt + Left】进入上一个编辑器选项<br>【f12】 进入上一个工具窗口<br>【esc】 从工具窗口进入编辑器<br>【Shift + Esc】 隐藏活动窗口<br>【Ctrl + Shift + F4】 关闭活动运行/消息/查找/选项卡<br>【Ctrl + G】 跳转到指定行<br>【Ctrl + E】 弹出最近打开的文件列表<br>【Ctrl + Alt + Left】导航前进<br>【Ctrl + Alt + Right】导航回退<br>【Ctrl + Shift +Backspace】定位到最近编辑窗口<br>【Alt + F1】查找当前选中的代码或文件在其他界面模块的位置<br>【Ctrl + B/Click】跳转到定义处<br>【Ctrl + 单击】转到声明<br>【Ctrl + Alt + B 】跳转方法实现处<br>【Ctrl + Shift + I】打开定义快速查找<br>【Ctrl + Shift + B 】跳转方法定义处<br>【Ctrl + U 】转到超级方法/超级类<br>【Alt + Up/Down】在方法间快速移动定位<br>【Ctrl +]/[】移动到代码块结束/启动<br>【Ctrl + f12】弹出文件结构<br>【Ctrl + H 】类型层次结构<br>【Ctrl + Alt + H】 调用层次结构<br>【F2/Shift + F2】跳转到后一个/前一个错误，在出错的语句之间进行跳转。<br>【F4/Ctrl + Enter】 编辑源代码/查看源代码<br>【Alt + home】 显示导航栏<br>【F11】切换标记<br>【Ctrl + F11】 采用记忆切换标记<br>【Ctrl + #[0-9]】跳转到带编号的标记<br>【Shift + F11 显示书签</p><h3 id="VCS版本控制"><a href="#VCS版本控制" class="headerlink" title="VCS版本控制"></a>VCS版本控制</h3><hr><p>【Alt + 反引号 (‘)】 ‘VCS’ 快速弹出<br>【Ctrl + K】提交项目到VCS<br>【Ctrl + T】 从VCS更新项目<br>【Alt + Shift + C】查看最近的更改</p><h3 id="搜索-替换"><a href="#搜索-替换" class="headerlink" title="搜索/替换"></a>搜索/替换</h3><hr><p>【Ctrl + F】 查找<br>【F3】 查找下一个<br>【Shift + F3】 查找上一个<br>【Ctrl + R】替换<br>【Ctrl + Shift + F】 在路径中找到<br>【Ctrl + Shift + R】 替换路径中的查找</p><h3 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h3><hr><p>【Alt + f7】查找实例<br>【Ctrl + f7】在文件中查找实例<br>【Ctrl + Shift + f7】 在文件中高亮实例<br>【Ctrl + Alt + F7】显示实例</p><h3 id="重构类"><a href="#重构类" class="headerlink" title="重构类"></a>重构类</h3><hr><p>【F5】拷贝当前文件<br>【F6】移动当前文件<br>【Alt + delete】 安全删除<br>【Shift + F6】 重命名<br>【Ctrl + Alt + N】嵌入变量<br>【Ctrl + Alt + M】提取函数<br>【Ctrl + Alt + V】引入变量<br>【Ctrl + Alt + C】引入常量<br>【Ctrl + Alt + P】引入参数<br>【Ctrl + F6】改变方法名</p><h3 id="常规类"><a href="#常规类" class="headerlink" title="常规类"></a>常规类</h3><hr><p>【Ctrl + Shift +a】 查找当前<br>【双击shift】查找所有的（包括文件、命令等）<br>【Alt + #[0-9]】 打开相应的工具窗口<br>【Ctrl + Shift + f12】 键切换最大化编辑器<br>【Alt + Shift + F】 将添加到收藏夹<br>【Alt + Shift + I】 检查当前文件与当前配置文件<br>【Ctrl + 反引号 (‘)】快速切换当前计划<br>【Ctrl + Alt + S】 打开设置<br>【Ctrl + Tab】 切换选项卡和工具窗口</p><h2 id="常用插件推荐"><a href="#常用插件推荐" class="headerlink" title="常用插件推荐"></a>常用插件推荐</h2><ol><li><p>Key Promoter【学习快捷键神器】<br>鼠标完成某项操作时，会提示相应的快捷键。</p></li><li><p>activate-power-mode【装*神器】<br>Atom上的神器，安装之后可以在 window -&gt; activate-power-mode中关闭震动以及开启彩色模式。</p></li><li><p>Markdown<br>支持Markdown语法</p></li><li><p>CodeGlance<br>之前用过Sublime编辑器同学，强烈推荐这个，这个插件可以让 webstorm 也具有右侧展示当前文件中代码的缩略图。</p></li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>webstorm可以像sublime一样多行选择，比如在sublime中全选一个单词然后使用cmd+d，就可以往下选择一样的单词，然后进入多行模式吗？</p><h3 id="逐个选中多个相同的词"><a href="#逐个选中多个相同的词" class="headerlink" title="逐个选中多个相同的词"></a><strong><em>逐个选中多个相同的词</em></strong></h3><p>sublime：Ctrl + D (Ctrl + K可以跳过一个)<br>webstrom：Ctrl + K ( Ctrl + Shift + K 可以回退一个)</p><h3 id="同时选中所有相同的词"><a href="#同时选中所有相同的词" class="headerlink" title="同时选中所有相同的词"></a><strong><em>同时选中所有相同的词</em></strong></h3><p>sublime：Alt + F3<br>webstrom：Ctrl + Shift + Alt + K</p><h3 id="单击左键选择多行"><a href="#单击左键选择多行" class="headerlink" title="单击左键选择多行"></a><strong><em>单击左键选择多行</em></strong></h3><p>sublime：按住Ctrl然后单击左键<br>webstrom：按住Alt然后单击左键</p><h3 id="拖动选择多行"><a href="#拖动选择多行" class="headerlink" title="拖动选择多行"></a><strong><em>拖动选择多行</em></strong></h3><p>sublime：按住Ctrl + Shift + 鼠标右键 拖动<br>webstrom：按住Alt + 鼠标右键 拖动</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 11:32:59 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;Webstorm是一款前端开发神器，此文介绍webstorm的快捷键和技巧分享。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://algate.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Webstrorm" scheme="http://algate.github.io/tags/Webstrorm/"/>
    
      <category term="快捷键" scheme="http://algate.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
      <category term="IDE" scheme="http://algate.github.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>站在人工智能风口的Python程序员</title>
    <link href="http://algate.github.io/archives/63096.html"/>
    <id>http://algate.github.io/archives/63096.html</id>
    <published>2017-08-25T08:12:19.000Z</published>
    <updated>2019-08-26T02:41:06.153Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 10:41:45 GMT+0800 (GMT+08:00) --><blockquote><p>2017年短短不到三个月的时间，国内AI获投项目已有36个，千万级别融资占据半数以上。</p></blockquote><p>嗯，就是那么霸道。两会刚刚结束，“人工智能”首次被列入政府工作报告，随之而来的是人工智能板块领跑大盘涨势，无疑，这一切将刺激人工智能在多个领域的全面发展。</p><p>大量融资的风口企业，绝对会把钱拿到招揽人才。而现在最流行的人工智能技术栈就是 TensorFlow 和 PyTorch，使用它们就是一份 Python 编程开发工作。一时间，python程序员成了人才市场的“抢手货”，工资待遇也水涨船高了。口说无凭，我们去工作搜索引擎jobui.com找看。一看吓一跳，首先是待遇啊：</p><p><img src="http://img.blog.csdn.net/20170318173404277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3psYWl5b25naGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="images"></p><p>最高待遇不过万不出奇啊！这还只是广州的情况，估计在北上深三个城市里，两者的差距还要大得多。除了待遇，跑到风口行业写Python，分分钟就是人工智能科学家的光环上身啊，估计大家都要跑得比西方记者还快了。</p><p>乐了Python程序员，苦的就是公司是Python技术栈的传统IT业务的企业了。就别提一般的小企业，连豆瓣、知乎这样的都大受冲击了。豆瓣的洪强宁，也跑去创业做人工智能相关的应用了……</p><p>没有人能够对抗趋势，风口企业这么有钱，能做的就只能是避开它们的锋芒。我觉得Python技术栈的企业应该考虑新的技术选型了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 10:41:45 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;2017年短短不到三个月的时间，国内AI获投项目已有36个，千万级别融资占据半数以上。&lt;/p&gt;&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="要闻" scheme="http://algate.github.io/categories/%E8%A6%81%E9%97%BB/"/>
    
    
      <category term="python" scheme="http://algate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>永久免费翻樯大杀器(不限速)</title>
    <link href="http://algate.github.io/archives/61443.html"/>
    <id>http://algate.github.io/archives/61443.html</id>
    <published>2017-08-24T08:12:19.000Z</published>
    <updated>2019-08-26T02:41:12.942Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 10:41:45 GMT+0800 (GMT+08:00) --><blockquote><p>网上免费翻墙的网站、软件、账号越来越少了，不是要天天签到就是不定时更换帐号密码，速度不理想，也不稳定。今天推荐GFW.Press。需要翻墙注册，无翻墙软件的可下载Lantern，用法不多说，自己动手丰衣足食。</p></blockquote><h3 id="现在已经大家都能够翻樯了-接下来就要使用免费服务了"><a href="#现在已经大家都能够翻樯了-接下来就要使用免费服务了" class="headerlink" title="现在已经大家都能够翻樯了.接下来就要使用免费服务了:"></a>现在已经大家都能够翻樯了.接下来就要使用免费服务了:</h3><h4 id="1-登录gfw-press官网-这里需要翻樯"><a href="#1-登录gfw-press官网-这里需要翻樯" class="headerlink" title="1.登录gfw.press官网(这里需要翻樯)"></a>1.登录gfw.press官网<strong>(这里需要翻樯)</strong></h4><h4 id="2-点击注册"><a href="#2-点击注册" class="headerlink" title="2.点击注册"></a>2.点击注册</h4><h4 id="3-注册成功后点击登录-你将会看到节点信息"><a href="#3-注册成功后点击登录-你将会看到节点信息" class="headerlink" title="3.注册成功后点击登录,你将会看到节点信息"></a>3.注册成功后点击登录,你将会看到节点信息</h4><p><img src="http://dn-cnode.qbox.me/FjRR4JHK1lc6SzxNtnAc8HmumyOH" alt="image"></p><h4 id="4-下载gfw-press软件"><a href="#4-下载gfw-press软件" class="headerlink" title="4.下载gfw.press软件"></a>4.下载gfw.press软件</h4><h4 id="5-安装完毕后双击打开-并安装gfw-press官网中提供的账号填入节点-端口以及密码"><a href="#5-安装完毕后双击打开-并安装gfw-press官网中提供的账号填入节点-端口以及密码" class="headerlink" title="5.安装完毕后双击打开,并安装gfw.press官网中提供的账号填入节点,端口以及密码."></a>5.安装完毕后双击打开,并安装gfw.press官网中提供的账号填入节点,端口以及密码.</h4><h4 id="6-打开谷歌浏览器-搜索chrome网上应用店-打开并搜索插件switchomega-安装插件-这里需要翻樯"><a href="#6-打开谷歌浏览器-搜索chrome网上应用店-打开并搜索插件switchomega-安装插件-这里需要翻樯" class="headerlink" title="6.打开谷歌浏览器,搜索chrome网上应用店,打开并搜索插件switchomega,安装插件   (这里需要翻樯)"></a>6.打开谷歌浏览器,搜索chrome网上应用店,打开并搜索插件switchomega,安装插件 (这里需要翻樯)</h4><p><img src="http://dn-cnode.qbox.me/FjJmrA7AVIocymjZN_-SN2RgrPih" alt="image"></p><h4 id="7-下载完毕后-你的谷歌浏览器右上角将多出一个小图标-单击选项按钮进入管理界面"><a href="#7-下载完毕后-你的谷歌浏览器右上角将多出一个小图标-单击选项按钮进入管理界面" class="headerlink" title="7.下载完毕后,你的谷歌浏览器右上角将多出一个小图标.单击选项按钮进入管理界面."></a>7.下载完毕后,你的谷歌浏览器右上角将多出一个小图标.单击选项按钮进入管理界面.</h4><p><img src="http://n//dn-cnode.qbox.me/FvkjspPx9UswCmRl07ZUkxnqSJ8q" alt="image"></p><h4 id="8-进入管理界面后-进行如下配置"><a href="#8-进入管理界面后-进行如下配置" class="headerlink" title="8.进入管理界面后,进行如下配置"></a>8.进入管理界面后,进行如下配置</h4><ul><li>新建情景模式</li></ul><p><img src="http://dn-cnode.qbox.me/FkRw9vxJhAECricmXA4xbjG318x6" alt="image"></p><ul><li>填入路由信息</li></ul><p><img src="http://dn-cnode.qbox.me/FqqxP52d_OWXfxc2BZMuHViObcsm" alt="image"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 10:41:45 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;网上免费翻墙的网站、软件、账号越来越少了，不是要天天签到就是不定时更换帐号密码，速度不理想，也不稳定。今天推荐GFW.P
      
    
    </summary>
    
      <category term="工具" scheme="http://algate.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="gfw" scheme="http://algate.github.io/tags/gfw/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript代码检查工具对比</title>
    <link href="http://algate.github.io/archives/26064.html"/>
    <id>http://algate.github.io/archives/26064.html</id>
    <published>2017-04-03T07:51:30.000Z</published>
    <updated>2019-02-27T03:29:53.800Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 11:33:11 GMT+0800 (GMT+08:00) --><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1503571860528&amp;di=0fecd1d75a0d57851a782f0da053a047&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D3845209004%2C4113255300%26fm%3D214%26gp%3D0.jpg" alt="image"></p><p>JavaScript代码校验工具能够让你在写代码时避免一些低级的错误。尽管我有很多年的开发经验，我仍然会犯一些语法错误并且忘记处理我的错误。一个好的校验工具或者格式化工具，可以让我避免这些错误，以免浪费我的时间。一个好的校验工具还能确保一个项目保持一个固定的代码风格。</p><p>有很多关于JavaScript的校验工具，你怎样选择其中的某一个呢？让我们一起来看看它们有什么样的特性以及优缺点。接下来我要介绍四种常用的选择：JSLint，JSHint，JSCS和ESLint。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>这四个工具的基本用法都是类似的，它们定义了一套规则用来解析和报告js文件里面的问题。它们都可以通过npm来进行安装。可以通过命令行来调用它们，给命令行传递文件参数，也可以作为grunt这一类工具的插件被使用，或者可以集成到编辑器中。它们都支持使用注释作为配置。</p><p>以上就是它们所有的相似之处了，每一个工具都有优缺点，只是有些工具相比于其它工具更加有优势。</p><h2 id="JSLint"><a href="#JSLint" class="headerlink" title="JSLint"></a>JSLint</h2><p>JSLint是这四种校验工具中最为古老的。Douglas Crockford（译注:《JavaScript 语言精粹》的作者）在2002年创造了它，它是强制使用的，为了保留它所认为的JavaScript这门语言的精华部分。如果你认同他的观点，对你而言，JSLint将会是一个好的工具。安装完成马上即可使用。</p><p>JSLint的缺点是它是不可以进行配置和扩展的。你不能禁用它的某些特性，并且缺乏文档。它的官网并没有什么用处，例如，它缺少如果将这个工具整合到你的编辑器的任何信息。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>配置规则都已经定好了，安装即可使用（如果你同意这些强制的规则的话）</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>JSLint没有可配置文件，你无法对它的规则进行更改</li><li>配置规则的数量有限，有些规则无法禁用</li><li>不支持自定义规则</li><li>缺少文档</li><li>很难定位到哪条规则导致了错误</li></ul><h2 id="JSCSC"><a href="#JSCSC" class="headerlink" title="JSCSC"></a>JSCSC</h2><p>JSCS和以上两个都是不同的，如果不给它一个配置文件或者使用一套预设的规则，它将什么也不做不了，不过你可以从别的网站下载配置文件，所以这并不是什么大问题，并且它有很多的预设规则，比如说jQuery的代码风格的预设规则以及Google的代码风格的预设规则。</p><p>它有超过90种不同的规则，并且你可以通过插件创造自定义规则。JSCS也支持自定义输出报告，这使得其更容易与需要其以特定格式输入的工具集成。</p><p>JSCS是一个代码风格检查器，这意味着它只捕获与代码格式相关的问题，而不包含潜在的错误。因此，它比其他工具的灵活性更低，但是如果您需要强制执行特定的编码风格，那么JSCS就可以做的很好。</p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul><li>支持自定义输出报告，可以使其更容易和其它工具进行集成</li><li>如果您遵循现有的可用编码风格之一，预设和现成的配置文件可以轻松设置</li><li>在报告中，有一个标志包含在规则名之中，所以很容易找出是哪条规则导致了错误</li><li>可以利用自定义的插件进行拓展</li></ul><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>只检测到代码风格的违规，不检测潜在的错误，比如说未使用的变量或者变量的全局污染等</li><li>四个工具中性能最差的，但是这并不是一个典型用途的问题</li></ul><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>ESLint是这四个工具中最新的，它被设计为易于拓展的，具有大量的自定义规则，并且很容易通过插件的形式来安装。它输出简洁的报告，但是默认包含规则的名称，因此你始终知道是那条规则导致了错误的信息。</p><p>ESLint的文档多少有些混乱，规则的列表容易查找，并且按逻辑进行分类，但配置说明在某些地方有点混乱。然而，它提供了如何对编辑器进行集成，插件和示例的链接。</p><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul><li>灵活：任何规则都可以切换使用，并且有些规则有额外的配置可以使用</li><li>可拓展性好，并且有很多可用的插件</li><li>易于理解的输出报告</li><li>包含一些其它工具所没有的规则，使得ESLint更容易检测出代码中潜在的错误</li><li>对ES6的支持性最好，是唯一支持JSX的工具</li><li>支持自定义输出报告</li></ul><h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>需要一些配置</li><li>性能差，但这并不是主要的障碍</li></ul><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>一个好的校验工具是捕捉问题非常重要的一步，但是它只能检测出它的规则许可范围之内的错误。对于更多简单明了的bug的捕捉，我建议使用单元测试，Code reviews也是也是不错的方式。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 11:33:11 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9
      
    
    </summary>
    
      <category term="前端" scheme="http://algate.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://algate.github.io/tags/JavaScript/"/>
    
      <category term="jsLint" scheme="http://algate.github.io/tags/jsLint/"/>
    
  </entry>
  
</feed>
