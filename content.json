{"meta":{"title":"Onions说前端 - 从未如此简单有趣","subtitle":"不要跟我谈理想，我的理想是不上班","description":"未来如何尚未定论，时间会给我答案。","author":"onions","url":"http://algate.github.io"},"pages":[],"posts":[{"title":"微信公众号Django-内网穿透-服务器配置-python环境-token验证.md","slug":"微信公众号Django-内网穿透-服务器配置-python环境-token验证","date":"2019-08-31T04:44:30.000Z","updated":"2019-08-31T08:49:38.408Z","comments":true,"path":"archives/JS190831.html","link":"","permalink":"http://algate.github.io/archives/JS190831.html","excerpt":"","text":"说明: 微信公众号文档，以及python，好友后续的内容涉及的相关知识，都在python2.7版本下进行的测试验证python3.0+版本出现各种问题，so，以下内容都在python2.7的环境下有效,先安装python2.71.微信公众号开发者文档服务器配置1-1.搭建服务(Python Web服务)开发者文档这里就用Django搭建服务了，方便省事(不用自己写代码了)2.搭建Django(Python Web 框架)2.1 安装DjangoDjango官方直接看 如何在Windows上安装Django？[1]pip install Django(推荐 pip为python的安装工具也可以使用easy_install django来进行安装)2.2 创建your first Django apphttps://docs.djangoproject.com/en/2.2/intro/tutorial01/django-admin startproject mysite mysite为你要创建的web站文件夹 我的为 DjangoWechat创建完之后，文件夹下会有一个文件夹，cd之后，里边还有个一相同的文件夹名mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 2.3 启动服务py manage.py runserver 8080打开浏览器就可以看到成功的默认页面2.4 部署自己的app项目首先创建一个存放你项目的apppython manage.py startapp polls 我的是wechatpolls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py Django默认是吧页面放到templates下的，资源是放在static下的一般打包的项目index.html加一个static文件夹，so 复制你的项目到polls下，把index.html放到templates下即可，不需要修改你项目里的路径2.5 访问服务下的index.html2.5.1 修改Djangon项目下urls.py# 导入app from polls(wechat) import views # add url(r&apos;^$&apos;, views.home, name=&apos;home&apos;), 2.5.2 修改polls(wechat)下views.py# from django.shortcuts import render from django.shortcuts import render, render_to_response, HttpResponse def home(request): return render_to_response(&apos;index.html&apos;) 现在应该可以看到index.html效果展示了3.微信服务器配置token验证3.1 公众号登录 - 基础配置 - 服务器配置服务器地址(URL) ： http://此处可以通过内网穿透来实现自己的域名/weixin/(weixin这个自己定义，需要和Django下的定义的接口一致就行)令牌(Token)：设置自己的我是起的项目名CloudUI消息加解密密钥(EncodingAESKey)：点击按钮自动生成3.2 点击提交，你会发现报错token验证失败 - 只是最多的提示，就是微信发送请求，没哟得到正确的结果请求超时，说明服务没起4.Django服务添加验证接口4.1 修改Django项目下的urls.py4.1.1修改Djangon项目下urls.py# 添加接口(views为之前修改首页导入的app的入口模块，wechat为定义的app下的访问的模块方法) url(r&apos;weixin/.*&apos;, views.wechat), 4.1.2 修改polls(wechat)下views.py# add wechat-token from django.views.decorators.csrf import csrf_exempt # 解除csrf验证 from wechat_sdk import WechatConf from wechat_sdk import WechatBasic ## add wechat-token conf = WechatConf( # 实例化配置信息对象 token=&apos;&apos;, # 服务器配置-Token appid=&apos;&apos;, # 公众号开发信息-开发者ID appsecret=&apos;&apos;, # 公众号开发信息-开发者密码 encrypt_mode=&apos;normal&apos;, # 服务器配置-明文模式 encoding_aes_key=&apos;&apos; # 服务器配置-EncodingAESKey ) @csrf_exempt # 去除csrf验证 def wechat(request): signature = request.GET.get(&apos;signature&apos;) # 获取请求信息 timestamp = request.GET.get(&apos;timestamp&apos;) nonce = request.GET.get(&apos;nonce&apos;) wechat_instance = WechatBasic(conf=conf) # 实例化微信基类对象 if not wechat_instance.check_signature(signature=signature, timestamp=timestamp, nonce=nonce): # 检查验证请求的签名 return HttpResponseBadRequest(&apos;Verify Failed&apos;) else: if request.method == &apos;GET&apos;: return HttpResponse(request.GET.get(&apos;echostr&apos;, None)) # 返回请求中的回复信息 4.2 安装wechat-sdkpip install wechat-sdk此处服务如果报错 |_4.3 Unable to find vcvarsall.bat(有可能是找不到模块导致的)(安装python的时候可能报错 - 此处如果报错跟这个可能关系不大 - 往上翻)报错往上翻，不是文档往上翻Unable to find vcvarsall.bat4.4 安装Crypto官方验证有个Python实例(用于验证的)：目录: E:\\JavascriptCode\\webPy\\微信公众号\\SampleCode\\Python Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2017/7/27 20:40 795 ierror.py -a---- 2017/7/27 20:40 2372 Sample.py -a---- 2017/7/27 20:40 9400 WXBizMsgCrypt.py -a---- 2017/7/27 20:40 0 __init__.py 如果用到WXBizMsgCrypt.py，在windows会报错from Crypto.Cipher import AES ImportError: No module named ‘Crypto’可以直接pip install Crypto 如果成功，直接看第五步，如果不成功就接着看。里边有这么一段：“””关于Crypto.Cipher模块，ImportError: No module named ‘Crypto’解决方案请到官方网站 https://www.dlitz.net/software/pycrypto/ 下载pycrypto。下载后，按照README中的“Installation”小节的提示进行pycrypto安装。“””下载pycrypto-2.6.1.tar.gz文件接4.44.5 解压pycrypto下找到readme文件的Installation执行 python setup.py install会发现报错Unable to find vcvarsall.bat(此处关系不大，否则python安装会提示)先验证vb，vc是否安装？Unable to find vcvarsall.bat如果还是报错Python安装目录\\Lib\\site-packages下是否有Crypto如果有，保证首字母大写如果没有，copy一份放进去。重新执行 py setup.py install（pip install Crypto）即可，只要最后出现successing的字样就表示你成功了！5.内网穿透5.1 网上随便找一个就ok，只要能外网访问到项目就okDjango 与 设置的外网访问的 端口号要保持一致127.0.0.1带上微信请求的接口自己本地先测试下。是否ok，欧克的话就可以公众号验证token了。此处需要把127.0.0.1 /内网穿透的域名 配置到Django环境下settings.py的ALLOWED_HOSTS = []里如果不成功那就看看报错出在哪里。慢慢解决此处的域名访问填写到微信公众号的服务器配置里分别填写token，密钥然后提交，就会发现token验证成功了，如果报错，请上翻查找原因","categories":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://algate.github.io/tags/微信公众号/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}]},{"title":"内网穿透工具","slug":"内网穿透工具","date":"2019-08-29T03:20:30.000Z","updated":"2019-09-06T03:07:31.882Z","comments":true,"path":"archives/JS190829.html","link":"","permalink":"http://algate.github.io/archives/JS190829.html","excerpt":"","text":"1.内网穿透工具1-1.ngrok1-2.Natapp1-3.localtunnel安装localtunnelnpm install -g localtunnel开启localtunnel服务1）指定的端口号 –port 8000 必须与 localhost的8000相对应2）–subdomain mitu : 指定前缀为 mitu3） lt 为localtunnel 缩写4. 最后, 在外网浏览器输入 https://mitu.localtunnel.me 即可访问本地的localhost:8000， 需要注意的是，localtunnel的服务器是国外，有时候访问可能不太理想1-4.uTools:1-5.open-dingtalk/pierced地址cmd下运行命令http://u.tools/其他参考地址前5个都是基于国外的ngrok来进行二次开发的。1、Ngrokngrok 是一个反向代理，通过在公共端点和本地运行的 Web 服务器之间建立一个安全的通道，实现内网主机的服务可以暴露给外网。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放，所以ngrok可以很方便地协助服务端程序测试。参考博客：10分钟教你搭建自己的ngrok服务器2、Natappnatapp是 基于ngrok的国内收费内网穿透工具，类似花生壳，有免费版本，比花生壳好。免费版本：提供http,https,tcp全隧道穿透，随机域名/TCP端口，不定时强制更换域名/端口，自定义本地端口参考文章：NATAPP1分钟快速新手图文教程3、小米球小米球是基于ngrok二次开发的内网穿透工具，支持多协议、多隧道、多端口同时映射(http、https、tcp等等…)，同时支持多种系统win、linux、linux_arm、mac等。具体的使用直接参考官网。4、Sunny-NgrokSunny-Ngrok同样是ngrok二次开发的内网穿透工具，支持http,https协议，同时支持更丰富的系统和语言：linux、win、mac、openwrt、 python、php等。教程：Sunny-Ngrok使用教程5、echositeechosite同样ngrok二次开发的内网穿透工具，支持多种协议，以前是全部免费的，现在推出了收费版和免费版，可根据自己的需要去选择。参考教程：EchoSite—让内网穿透变得简单6、Ssh、autosshssh 配合autossh工具使用，因为autossh会容错，自动重新启动SSH会话和隧道。autossh是一个程序，用于启动ssh的副本并进行监控，在死亡或停止传输流量时根据需要重新启动它。 这个想法来自rstunnel（Reliable SSH Tunnel），但是在C中实现。作者的观点是，它不像匆匆忙忙的工作那么容易。使用端口转发环路或远程回显服务进行连接监视。在遇到连接拒绝等快速故障时，关闭连接尝试的速度。在OpenBSD，Linux，Solaris，Mac OS X，Cygwin和AIX上编译和测试; 应该在其他BSD上工作。免费软件。使用教程：SSH内网穿透7、Lanproxylanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，目前仅支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面…）。目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。参考教程：业余草推荐一款局域网（内网）穿透工具lanproxy8、SpikeSpike是一个可以用来将你的内网服务暴露在公网的快速的反向代理，基于ReactPHP，采用IO多路复用模型。采用Php实现。参考教程：使用 PHP 实现的的内网穿透工具 “Spike”9、Frpfrp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。教程：一款很好用的内网穿透工具–FRP、使用frp实现内网穿透10、FcnFCN[free connect]是一款傻瓜式的一键接入私有网络的工具, fcn利用公共服务器以及数据加密技术实现：在免公网IP环境下，在任意联网机器上透明接入服务端所在局域网网段。支持多种系统，有免费版和付费版","categories":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}],"tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://algate.github.io/tags/前端工具/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}]},{"title":"JavaScript好用的Web-Api","slug":"JavaScript好用的Web-Api","date":"2019-08-26T02:57:30.000Z","updated":"2019-09-06T03:50:29.600Z","comments":true,"path":"archives/JS190826.html","link":"","permalink":"http://algate.github.io/archives/JS190826.html","excerpt":"","text":"1.closest（元素向上查询）closest跟querySelector相反，该元素可以向上查询，也就是可以查询到父元素：document.querySelector(“li”).closest(“#nav”);2.dataset（获取元素以”data-“为前缀的属性集合）dataset就跟原生微信小程序一样，能获取标签上以”data-“为前缀的属性集合：document.querySelector(“p”).dataset; // {name: “蜘蛛侠”, age: “16”}注意：虽然可以用getAttribute方法获取任何属性值，但是性质却不一样，这是开发规范问题，凡是自定义属性都要加上data-前缀哦3.URLSearchParams（查询参数）URLSearchParams假设浏览器的url参数是 “?name=蜘蛛侠&amp;age=16”：1new URLSearchParams(location.search).get(\"name\"); // 蜘蛛侠4.hidden（隐藏元素）这是一个html属性，规定元素是否隐藏，表现跟css的display: none一致：&lt;div hidden&gt;我被隐藏了&lt;/div&gt;document.querySelector(&quot;div&quot;).hidden = true / false;5.classList（类名控制器）classList这是一个对象，该对象里封装了许多操作元素类名的方法：&lt;p class=&quot;title&quot;&gt;&lt;/p&gt;1234567891011let elem = document.querySelector(\"p\");// 增加类名elem.classList.add(\"title-new\"); // \"title title-new\"// 删除类名elem.classList.remove(\"title\"); // \"title-new\"// 切换类名（有则删、无则增，常用于一些切换操作，如显示/隐藏）elem.classList.toggle(\"title\"); // \"title-new title\"// 替换类名elem.classList.replace(\"title\", \"title-old\"); // \"title-new title-old\"// 是否包含指定类名elem.classList.contains(\"title\"); // false6.contains（判断是否包含指定元素）contains可以判断指定元素是否包含了指定的子元素：1234&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;document.querySelector(\"div\").contains(document.querySelector(\"p\")); // true7.online state（网络状态）online state监听当前的网络状态变动，然后执行对应的方法：12345window.addEventListener(\"online\", xxx);window.addEventListener(\"offline\", () =&gt; &#123; alert(\"你断网啦！\");&#125;);使用场景：提示用户已断网，直接一个弹框把用户吓懵8.battery state（电池状态）battery state获取设备的电池状态：12345678910111213navigator.getBattery().then(battery =&gt; console.log(battery));// 返回&#123; charging, // 是否在充电 chargingTime, // 充满电所需时间 dischargingTime, // 当前电量可使用时间 level, 剩余电量 onchargingchange, // 监听充电状态变化 onchargingtimechange, // 监听充满电所需时间变化 ondischargingtimechange, // 监听当前电量可使用时间变化 onlevelchange // 监听电量变化&#125;使用场景：提示用户电量已充满，或者为了让用户有安全感，电量低于99%的时候来个弹框提示”该充电啦”9.vibration（设备震动）嘻嘻，使设备进行震动：// 震动一次navigator.vibrate(100);// 连续震动，震动200ms、暂停100ms、震动300msnavigator.vibrate([200, 100, 300]);效果如下：不好意思你得用你自己的手握住手机才能感受得到;使用场景：通过振动来提供感官反馈，比如太久没有触摸屏幕的时候连续震动提醒用户10.page visibility（页面可见性）顾名思义，这个API是用来监听页面可见性变化的，在PC端标签栏切换、最小化会触发、在移动端程序切到后台会触发，简单说就是页面消失了🤦‍♂️123document.addEventListener(\"visibilitychange\", () =&gt; &#123; console.log(`页面可见性：$&#123;document.visibilityState&#125;`);&#125;);PC端效果如下：移动端效果如下：使用场景：当程序切到后台的时候，如果当前有视频播放或者一些动画执行，可以先暂停11.deviceOrientation（陀螺仪）deviceOrientation陀螺仪，也就是设备的方向，又名重力感应，该API在IOS设备上失效的解决办法，将域名协议改成https；从左到右分别为alpha、beta、gamma:1234567891011window.addEventListener(\"deviceorientation\", event =&gt; &#123; let &#123; alpha, beta, gamma &#125; = event; console.log(`alpha：$&#123;alpha&#125;`); console.log(`beta：$&#123;beta&#125;`); console.log(`gamma：$&#123;gamma&#125;`);&#125;);使用场景：页面上的某些元素需要根据手机摆动进行移动，达到视差的效果，比如王者荣耀进入游戏的那个界面，手机转动背景图会跟着动12.toDataUrl（画布内容转base64）toDataURL这个canvas的API，作用是将画布的内容转换成一个base64的图片地址：1234let canvas = document.querySelector(\"canvas\");let context = canvas.getContext(\"2d\");//……let url = canvas.toDataURL(\"image/png\"); // 将画布内容转换成base64地址使用a标签进行图片下载时，图片链接跨域（图片是我的掘金头像），无法进行下载而是进行图片预览：1234&lt;img src=\"xxx\"&gt;&lt;button&gt; &lt;a href=\"xxx\" download=\"avatar\"&gt;下载图片&lt;/a&gt;&lt;/button&gt;封装以下代码便可解决✅12345678910111213141516171819202122232425const downloadImage = (url, name) =&gt; &#123; // 实例化画布 let canvas = document.createElement(\"canvas\"); let context = canvas.getContext(\"2d\"); // 实例化一个图片对象 let image = new Image(); image.crossOrigin = \"Anonymous\"; image.src = url; // 当图片加载完毕 image.onload = () =&gt; &#123; // 将图片画在画布上 canvas.height = image.height; canvas.width = image.width; context.drawImage(image, 0, 0); // 将画布的内容转换成base64地址 let dataURL = canvas.toDataURL(\"image/png\"); // 创建a标签模拟点击进行下载 let a = document.createElement(\"a\"); a.hidden = true; a.href = dataURL; a.download = name; document.body.appendChild(a); a.click(); &#125;&#125;或者将当前的DOM转换成图片进行下载，常用于生成海报，推荐插件html2canvas，大家可以自己去搜;13.customEvent（自定义事件）customEvent自定义事件，就跟vue里面的on跟emit一样；监听自定义事件：123456789window.addEventListener(\"follow\", event =&gt; &#123; console.log(event.detail); // 输出 &#123;name: \"前端宇宙情报局\"&#125;&#125;);派发自定义事件：window.dispatchEvent(new CustomEvent(\"follow\", &#123; detail: &#123; name: \"前端宇宙情报局\" &#125;&#125;));14.notification（桌面通知）notificationPC端的桌面通知，如网页端的微信，当收到消息时，右下角会出现一个通知（尽管你把浏览器最小化），因为这个通知时独立于浏览器的，是系统的一个原生控件：1234567891011const notice = new Notification(\"前端宇宙情报局\", &#123; body: \"这20个不常用的Web API真的有用吗?，别问，问就是有用🈶\", icon: \"我的掘金头像\", data: &#123; url: \"https://www.baidu.com\" &#125;&#125;);// 点击回调notice.onclick = () =&gt; &#123; window.open(notice.data.url); // 当用户点击通知时，在浏览器打开百度网站&#125;效果如下：注意：想要成功的调起通知，首先要用户的授权✅Notification.requestPermission(prem =&gt; {prem == “granted” // 同意prem == “denied” // 拒绝})所以，再调用之前先向用户发起请求：12345678910let permission = Notification.permission;if (permission == \"granted\") &#123; // 已同意，开始发送通知 ...&#125; else if (permission == \"denied\") &#123; // 不同意，发不了咯&#125; else &#123; // 其他状态，可以重新发送授权提示 Notification.requestPermission();&#125;15.fullScreen（全屏）fullScreen全屏不咯? 之前的一个项目刚好用上，不仅仅可以作用在documentElement上，还可以作用在指定元素：12345678910111213/** * @method launchFullScreen 开启全屏 * @param &#123;Object&#125; elem = document.documentElement 作用的元素 */const launchFullScreen = (elem = document.documentElement) =&gt; &#123; if(elem.requestFullScreen) &#123; elem.requestFullScreen(); &#125; else if(elem.mozRequestFullScreen) &#123; elem.mozRequestFullScreen(); &#125; else if(elem.webkitRequestFullScreen) &#123; elem.webkitRequestFullScreen(); &#125;&#125;作用在documentElement上没啥可以介绍的咯，就相当于F11开启全屏：那么作用在指定元素会是什么效果呢?就像效果图一样，会直接开启全屏，并且只显示指定的元素，元素的宽高填充了整个屏幕✅关闭全屏的时候需要注意的是，统一用document对象：123456789101112/** * @method exitFullScreen 关闭全屏 */const exitFullScreen = () =&gt; &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitCancelFullScreen) &#123; document.webkitCancelFullScreen(); &#125;&#125;使用场景：需要让用户专注去做某件事，比如代码编辑区的全屏16.orientation（屏幕方向）orientation可以监听用户手机设备的旋转方向变化：123window.addEventListener(\"orientationchange\", () =&gt; &#123; document.body.innerHTML += `&lt;p&gt;屏幕旋转后的角度值：$&#123;window.orientation&#125;&lt;/p&gt;`;&#125;, false);效果如下：也可以使用css的媒体查询：123456789101112/* 竖屏时样式 */@media all and (orientation: portrait) &#123; body::after &#123; content: \"竖屏\" &#125;&#125;/* 横屏时样式 */@media all and (orientation: landscape) &#123; body::after &#123; content: \"横屏\" &#125;&#125;使用场景：页面需要用户开启横屏来获得更好的体验17.getBoundingClientRect（元素空间结构详细信息）getBoundingClientRect可以获取指定元素在当前页面的空间信息：123456789101112elem.getBoundingClientRect();// 返回&#123; x: 604.875, y: 1312, width: 701.625, height: 31, top: 1312, right: 1306.5, bottom: 1343, left: 604.875&#125;注意：top是距离文档顶部的距离，y则是距离可视窗口（浏览器屏幕）的顶部距离，如果浏览器滚动，top值不变，y值会变· MDN Web API接口","categories":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://algate.github.io/tags/JavaScript/"},{"name":"WebApi","slug":"WebApi","permalink":"http://algate.github.io/tags/WebApi/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}]},{"title":"JavaScript工具相关使用","slug":"JavaScript工具相关使用","date":"2019-04-26T02:38:30.000Z","updated":"2019-08-26T03:33:07.431Z","comments":true,"path":"archives/JS190426.html","link":"","permalink":"http://algate.github.io/archives/JS190426.html","excerpt":"","text":"1.serve不用express,不用部署http环境,可以直接运行编译后代码用法：serve -s ./docs -p 8888安装：node环境全局安装 serve 依赖 （ cnpm install -g serve ）2.font-spider打包文件之后，可以压缩页面中引用的字体文件（字体图标除外）用法：font-spider ./html文件路径安装：cnpm install font-spider -g","categories":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://algate.github.io/tags/JavaScript/"},{"name":"打包工具","slug":"打包工具","permalink":"http://algate.github.io/tags/打包工具/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}]},{"title":"睡前收入睡后收入第一节","slug":"睡前收入睡后收入第一节","date":"2019-04-16T12:19:00.000Z","updated":"2019-08-26T02:33:40.614Z","comments":true,"path":"archives/54500.html","link":"","permalink":"http://algate.github.io/archives/54500.html","excerpt":"","text":"睡前收入，睡后收入。你能明白，你就实现了自由！一个人，只要不是含着金钥匙出生的，财富最初总是靠出售体力或智力劳动换来的，并在满足我们消费需求之后，通过配置在不同的资产上获取。套用一句流行语，或者是“睡前收入”，或者是“睡后收入”。所谓睡前收入，就是你干活就有、睡着了就没有的那种，使用自己的体力或者智力还钱。所谓睡后收入，就是被动性收入，哪怕你睡着了，它也在自动增值。两种收入形态中，很明显，睡后收入占比越高，你就有越多可供自由支配的时间，所做选择受到的制约也就越少。收入来源全部由睡后收入构成，就进入了所谓财务自由状态。受限于认知水平，我们最先接触到的睡后收入，可能都是银行存款,还是年回报率“高”达0.35%的活期存款，其后由于你多学习了一点点，你可能开始会搞阿里余额宝、腾讯理财通、甲银行B理财…… ，收益率开始从0.35%提升到3%~5%之间。这一步很容易实现，是因为这个回报率依然远在社会平均财富增长值之下，属于将自己辛辛苦苦卖体力或者脑力换来的财富，无偿地送给别人一部分。将财富从自己口袋里掏出来.","categories":[{"name":"日记","slug":"日记","permalink":"http://algate.github.io/categories/日记/"}],"tags":[{"name":"理财","slug":"理财","permalink":"http://algate.github.io/tags/理财/"}],"keywords":[{"name":"日记","slug":"日记","permalink":"http://algate.github.io/categories/日记/"}]},{"title":"史上最全的Webstorm快捷键及技巧","slug":"史上最全的Webstorm快捷键大全","date":"2017-09-21T02:44:48.000Z","updated":"2019-08-26T02:27:05.193Z","comments":true,"path":"archives/47814.html","link":"","permalink":"http://algate.github.io/archives/47814.html","excerpt":"","text":"Webstorm是一款前端开发神器，此文介绍webstorm的快捷键和技巧分享。所谓工欲善其事，必先利其器嘛，想着如果要提高开发效率，那掌握一些常用的快捷键应该是少不了的，所以把webstorm快捷键及技巧分享给大家。持续更新中webstorm官方下载地址：http://www.jetbrains.com/webstorm/快捷键大全编辑类【Ctrl + Space 】基本代码完成 （任何类、 方法或变量名称）【Alt + Enter】 展示意图动作和快速修复【Ctrl + P】显示调用方法内参数信息【Ctrl + Q】 快速记录查找【Ctrl + mouse】放在代码上面-显示简短的代码信息【Ctrl + F1】在插入符号显示错误或警告的说明【Alt + Insert】生成代码【Ctrl + Alt + T】快速生成（if..else, try..catch, for, etc.）等【Ctrl + J】插入Live模板【Ctrl + / 】行注释与取消行注释【Ctrl + Shift + / 】块注释与取消块注释【Ctrl + W 】增加选择中代码块【Ctrl + Shift + W 】减少当前所选内容代码块【Alt + Q 】上下文信息【Ctrl + Alt + L 】格式化代码【Ctrl + Alt + I 】自动缩进的行数【Tab / Shift + Tab 】缩进/取消缩进选定的行【Ctrl + X , Shift + Delete】 剪切到剪贴板的当前行或者所选代码块【Ctrl + C】Ctrl + 插入复制当前行或者所选代码块到剪贴板【Ctrl + V】Shift + 从剪贴板插入粘贴【Ctrl + Shift + V 】最近缓冲区粘贴【Ctrl + D】复制当前行或者所选代码块【Ctrl + Y】删除行【Ctrl + Shift + J 】加入行【Ctrl + enter 】拆分行【shift + Enter 】 重新开始一行（无论光标在哪个位置）【Ctrl + Shift + U 】切换选中词或所选代码块的大小写【Ctrl + Shift +]】选中直到代码块的开始【Ctrl + Shift +[】选择直到代码块的结束【Ctrl + Delete】 删除光标右侧的词【Ctrl + backspace】 删除光标左侧的词【Ctrl + NumPad+】展开代码块【Ctrl + NumPad-】折叠代码块【Ctrl + Shift + NumPad+】展开所有代码块【Ctrl + Shift + NumPad-】折叠所有代码块【Ctrl + F4 】关闭当前标签页同时编辑多行【Alt + Click】 同时选中多行，同时编辑【Shift + Ctrl + Alt + J】选择所有当前选中的词【Alt + J】选择下一个相同的词【Alt + Shift + J】取消所有选中的词【Esc】取消选择所有选中的词或插入符号运行类【Alt + Shift + F10/F9】 选择配置和运行/调试【Shift + F10/F9】 运行/调试【Ctrl + Shift + F10/F9】 运行/调试上下文配置从编辑器【Alt + Shift + R】 重新运行测试调试类【F8】不进入函数【F7】 单步执行【Shift + F7】 只能单步执行【Shift + F8】跳出【Alt + F9】 运行到光标处【Alt + F8】 计算表达式的值【F9】 重新开始【Ctrl + f8】 切换断点【Ctrl + Shift + F8】 查看断点导航类【Ctrl + N】跳转到指定类【Ctrl + Shift + N】 通过文件名快速查找工程内的文件【Ctrl + Alt + Shift + N】 通过一个字符查找函数位置【Alt + Right】进入下一个编辑器选项【Alt + Left】进入上一个编辑器选项【f12】 进入上一个工具窗口【esc】 从工具窗口进入编辑器【Shift + Esc】 隐藏活动窗口【Ctrl + Shift + F4】 关闭活动运行/消息/查找/选项卡【Ctrl + G】 跳转到指定行【Ctrl + E】 弹出最近打开的文件列表【Ctrl + Alt + Left】导航前进【Ctrl + Alt + Right】导航回退【Ctrl + Shift +Backspace】定位到最近编辑窗口【Alt + F1】查找当前选中的代码或文件在其他界面模块的位置【Ctrl + B/Click】跳转到定义处【Ctrl + 单击】转到声明【Ctrl + Alt + B 】跳转方法实现处【Ctrl + Shift + I】打开定义快速查找【Ctrl + Shift + B 】跳转方法定义处【Ctrl + U 】转到超级方法/超级类【Alt + Up/Down】在方法间快速移动定位【Ctrl +]/[】移动到代码块结束/启动【Ctrl + f12】弹出文件结构【Ctrl + H 】类型层次结构【Ctrl + Alt + H】 调用层次结构【F2/Shift + F2】跳转到后一个/前一个错误，在出错的语句之间进行跳转。【F4/Ctrl + Enter】 编辑源代码/查看源代码【Alt + home】 显示导航栏【F11】切换标记【Ctrl + F11】 采用记忆切换标记【Ctrl + #[0-9]】跳转到带编号的标记【Shift + F11 显示书签VCS版本控制【Alt + 反引号 (‘)】 ‘VCS’ 快速弹出【Ctrl + K】提交项目到VCS【Ctrl + T】 从VCS更新项目【Alt + Shift + C】查看最近的更改搜索/替换【Ctrl + F】 查找【F3】 查找下一个【Shift + F3】 查找上一个【Ctrl + R】替换【Ctrl + Shift + F】 在路径中找到【Ctrl + Shift + R】 替换路径中的查找搜索类【Alt + f7】查找实例【Ctrl + f7】在文件中查找实例【Ctrl + Shift + f7】 在文件中高亮实例【Ctrl + Alt + F7】显示实例重构类【F5】拷贝当前文件【F6】移动当前文件【Alt + delete】 安全删除【Shift + F6】 重命名【Ctrl + Alt + N】嵌入变量【Ctrl + Alt + M】提取函数【Ctrl + Alt + V】引入变量【Ctrl + Alt + C】引入常量【Ctrl + Alt + P】引入参数【Ctrl + F6】改变方法名常规类【Ctrl + Shift +a】 查找当前【双击shift】查找所有的（包括文件、命令等）【Alt + #[0-9]】 打开相应的工具窗口【Ctrl + Shift + f12】 键切换最大化编辑器【Alt + Shift + F】 将添加到收藏夹【Alt + Shift + I】 检查当前文件与当前配置文件【Ctrl + 反引号 (‘)】快速切换当前计划【Ctrl + Alt + S】 打开设置【Ctrl + Tab】 切换选项卡和工具窗口常用插件推荐Key Promoter【学习快捷键神器】鼠标完成某项操作时，会提示相应的快捷键。activate-power-mode【装*神器】Atom上的神器，安装之后可以在 window -&gt; activate-power-mode中关闭震动以及开启彩色模式。Markdown支持Markdown语法CodeGlance之前用过Sublime编辑器同学，强烈推荐这个，这个插件可以让 webstorm 也具有右侧展示当前文件中代码的缩略图。常见问题webstorm可以像sublime一样多行选择，比如在sublime中全选一个单词然后使用cmd+d，就可以往下选择一样的单词，然后进入多行模式吗？逐个选中多个相同的词sublime：Ctrl + D (Ctrl + K可以跳过一个)webstrom：Ctrl + K ( Ctrl + Shift + K 可以回退一个)同时选中所有相同的词sublime：Alt + F3webstrom：Ctrl + Shift + Alt + K单击左键选择多行sublime：按住Ctrl然后单击左键webstrom：按住Alt然后单击左键拖动选择多行sublime：按住Ctrl + Shift + 鼠标右键 拖动webstrom：按住Alt + 鼠标右键 拖动","categories":[{"name":"工具","slug":"工具","permalink":"http://algate.github.io/categories/工具/"}],"tags":[{"name":"Webstrorm","slug":"Webstrorm","permalink":"http://algate.github.io/tags/Webstrorm/"},{"name":"快捷键","slug":"快捷键","permalink":"http://algate.github.io/tags/快捷键/"},{"name":"IDE","slug":"IDE","permalink":"http://algate.github.io/tags/IDE/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://algate.github.io/categories/工具/"}]},{"title":"站在人工智能风口的Python程序员","slug":"站在人工智能风口的Python程序员","date":"2017-08-25T08:12:19.000Z","updated":"2019-08-26T02:41:06.153Z","comments":true,"path":"archives/63096.html","link":"","permalink":"http://algate.github.io/archives/63096.html","excerpt":"","text":"2017年短短不到三个月的时间，国内AI获投项目已有36个，千万级别融资占据半数以上。嗯，就是那么霸道。两会刚刚结束，“人工智能”首次被列入政府工作报告，随之而来的是人工智能板块领跑大盘涨势，无疑，这一切将刺激人工智能在多个领域的全面发展。大量融资的风口企业，绝对会把钱拿到招揽人才。而现在最流行的人工智能技术栈就是 TensorFlow 和 PyTorch，使用它们就是一份 Python 编程开发工作。一时间，python程序员成了人才市场的“抢手货”，工资待遇也水涨船高了。口说无凭，我们去工作搜索引擎jobui.com找看。一看吓一跳，首先是待遇啊：最高待遇不过万不出奇啊！这还只是广州的情况，估计在北上深三个城市里，两者的差距还要大得多。除了待遇，跑到风口行业写Python，分分钟就是人工智能科学家的光环上身啊，估计大家都要跑得比西方记者还快了。乐了Python程序员，苦的就是公司是Python技术栈的传统IT业务的企业了。就别提一般的小企业，连豆瓣、知乎这样的都大受冲击了。豆瓣的洪强宁，也跑去创业做人工智能相关的应用了……没有人能够对抗趋势，风口企业这么有钱，能做的就只能是避开它们的锋芒。我觉得Python技术栈的企业应该考虑新的技术选型了。","categories":[{"name":"要闻","slug":"要闻","permalink":"http://algate.github.io/categories/要闻/"}],"tags":[{"name":"python","slug":"python","permalink":"http://algate.github.io/tags/python/"}],"keywords":[{"name":"要闻","slug":"要闻","permalink":"http://algate.github.io/categories/要闻/"}]},{"title":"永久免费翻樯大杀器(不限速)","slug":"永久免费翻樯大杀器(不限速)","date":"2017-08-24T08:12:19.000Z","updated":"2019-08-26T02:41:12.942Z","comments":false,"path":"archives/61443.html","link":"","permalink":"http://algate.github.io/archives/61443.html","excerpt":"","text":"网上免费翻墙的网站、软件、账号越来越少了，不是要天天签到就是不定时更换帐号密码，速度不理想，也不稳定。今天推荐GFW.Press。需要翻墙注册，无翻墙软件的可下载Lantern，用法不多说，自己动手丰衣足食。现在已经大家都能够翻樯了.接下来就要使用免费服务了:1.登录gfw.press官网(这里需要翻樯)2.点击注册3.注册成功后点击登录,你将会看到节点信息4.下载gfw.press软件5.安装完毕后双击打开,并安装gfw.press官网中提供的账号填入节点,端口以及密码.6.打开谷歌浏览器,搜索chrome网上应用店,打开并搜索插件switchomega,安装插件 (这里需要翻樯)7.下载完毕后,你的谷歌浏览器右上角将多出一个小图标.单击选项按钮进入管理界面.8.进入管理界面后,进行如下配置新建情景模式填入路由信息","categories":[{"name":"工具","slug":"工具","permalink":"http://algate.github.io/categories/工具/"}],"tags":[{"name":"gfw","slug":"gfw","permalink":"http://algate.github.io/tags/gfw/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://algate.github.io/categories/工具/"}]},{"title":"JavaScript代码检查工具对比","slug":"JavaScript代码检查工具对比","date":"2017-04-03T07:51:30.000Z","updated":"2019-02-27T03:29:53.800Z","comments":true,"path":"archives/26064.html","link":"","permalink":"http://algate.github.io/archives/26064.html","excerpt":"","text":"JavaScript代码校验工具能够让你在写代码时避免一些低级的错误。尽管我有很多年的开发经验，我仍然会犯一些语法错误并且忘记处理我的错误。一个好的校验工具或者格式化工具，可以让我避免这些错误，以免浪费我的时间。一个好的校验工具还能确保一个项目保持一个固定的代码风格。有很多关于JavaScript的校验工具，你怎样选择其中的某一个呢？让我们一起来看看它们有什么样的特性以及优缺点。接下来我要介绍四种常用的选择：JSLint，JSHint，JSCS和ESLint。Overview这四个工具的基本用法都是类似的，它们定义了一套规则用来解析和报告js文件里面的问题。它们都可以通过npm来进行安装。可以通过命令行来调用它们，给命令行传递文件参数，也可以作为grunt这一类工具的插件被使用，或者可以集成到编辑器中。它们都支持使用注释作为配置。以上就是它们所有的相似之处了，每一个工具都有优缺点，只是有些工具相比于其它工具更加有优势。JSLintJSLint是这四种校验工具中最为古老的。Douglas Crockford（译注:《JavaScript 语言精粹》的作者）在2002年创造了它，它是强制使用的，为了保留它所认为的JavaScript这门语言的精华部分。如果你认同他的观点，对你而言，JSLint将会是一个好的工具。安装完成马上即可使用。JSLint的缺点是它是不可以进行配置和扩展的。你不能禁用它的某些特性，并且缺乏文档。它的官网并没有什么用处，例如，它缺少如果将这个工具整合到你的编辑器的任何信息。优点：配置规则都已经定好了，安装即可使用（如果你同意这些强制的规则的话）缺点：JSLint没有可配置文件，你无法对它的规则进行更改配置规则的数量有限，有些规则无法禁用不支持自定义规则缺少文档很难定位到哪条规则导致了错误JSCSCJSCS和以上两个都是不同的，如果不给它一个配置文件或者使用一套预设的规则，它将什么也不做不了，不过你可以从别的网站下载配置文件，所以这并不是什么大问题，并且它有很多的预设规则，比如说jQuery的代码风格的预设规则以及Google的代码风格的预设规则。它有超过90种不同的规则，并且你可以通过插件创造自定义规则。JSCS也支持自定义输出报告，这使得其更容易与需要其以特定格式输入的工具集成。JSCS是一个代码风格检查器，这意味着它只捕获与代码格式相关的问题，而不包含潜在的错误。因此，它比其他工具的灵活性更低，但是如果您需要强制执行特定的编码风格，那么JSCS就可以做的很好。优点：支持自定义输出报告，可以使其更容易和其它工具进行集成如果您遵循现有的可用编码风格之一，预设和现成的配置文件可以轻松设置在报告中，有一个标志包含在规则名之中，所以很容易找出是哪条规则导致了错误可以利用自定义的插件进行拓展缺点：只检测到代码风格的违规，不检测潜在的错误，比如说未使用的变量或者变量的全局污染等四个工具中性能最差的，但是这并不是一个典型用途的问题ESLintESLint是这四个工具中最新的，它被设计为易于拓展的，具有大量的自定义规则，并且很容易通过插件的形式来安装。它输出简洁的报告，但是默认包含规则的名称，因此你始终知道是那条规则导致了错误的信息。ESLint的文档多少有些混乱，规则的列表容易查找，并且按逻辑进行分类，但配置说明在某些地方有点混乱。然而，它提供了如何对编辑器进行集成，插件和示例的链接。优点：灵活：任何规则都可以切换使用，并且有些规则有额外的配置可以使用可拓展性好，并且有很多可用的插件易于理解的输出报告包含一些其它工具所没有的规则，使得ESLint更容易检测出代码中潜在的错误对ES6的支持性最好，是唯一支持JSX的工具支持自定义输出报告缺点：需要一些配置性能差，但这并不是主要的障碍推荐一个好的校验工具是捕捉问题非常重要的一步，但是它只能检测出它的规则许可范围之内的错误。对于更多简单明了的bug的捕捉，我建议使用单元测试，Code reviews也是也是不错的方式。","categories":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://algate.github.io/tags/JavaScript/"},{"name":"jsLint","slug":"jsLint","permalink":"http://algate.github.io/tags/jsLint/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://algate.github.io/categories/前端/"}]}]}